<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>HKDF-Expand Inner Block Visualizer</title>
    <style>
        body { font-family: sans-serif; margin: 2em; background-color: #f4f4f9; color: #333; }
        h1, h2 { color: #444; border-bottom: 2px solid #ddd; padding-bottom: 5px; }
        .container { margin-bottom: 1em; }
        label { font-weight: bold; margin-right: 1em; display: block; margin-bottom: 5px; }
        #info-input { width: 100%; height: 80px; box-sizing: border-box; }
        #prepend-buttons button { margin-right: 10px; padding: 8px 12px; border: 1px solid #ccc; background-color: #e9e9e9; cursor: pointer; }
        #prepend-buttons button:hover { background-color: #ddd; }
        .legend { margin: 1em 0; display: flex; flex-wrap: wrap; gap: 15px; align-items: center; }
        .legend > div { padding: 5px 10px; border: 1px solid #ccc; display: flex; align-items: center; gap: 8px; }
        .legend .legend-viz { display: flex; width: 60px; height: 20px; border: 2px solid #aaa; }
        .legend .legend-viz > div { flex-grow: 1; }
        .output-section { margin-top: 2em; }
        .block-container { display: flex; border: 1px solid #666; height: 30px; margin-top: 5px; font-size: 12px; line-height: 30px; text-align: center; color: white; overflow: hidden; }
        .block-label { font-size: 0.8em; color: #555; }
        .segment { overflow: hidden; white-space: nowrap; box-sizing: border-box; border-right: 1px dotted rgba(255,255,255,0.3); }
        .segment:last-child { border-right: none; }
        .padding-wrapper { display: flex; border: 2px solid rgba(255, 255, 255, 0.7); box-sizing: border-box; }
        .key-block { background-color: #5cb85c; } /* Green */
        .t-prev { background-color: #d9534f; } /* Red */
        .info { background-color: #5bc0de; } /* Blue */
        .counter { background-color: #f0ad4e; } /* Orange */
        .eom { background-color: #777; } /* Gray */
        .unused { background-color: #8e44ad; } /* Purple */
        .length { background-color: #34495e; } /* Dark Blue/Gray */
    </style>
</head>
<body>

    <h1>HKDF-Expand Block Visualizer</h1>

    <div class="container">
        <label for="hash-select">Hash Function:</label>
        <select id="hash-select">
            <option value="SHA-256">SHA-256 (64-byte blocks)</option>
            <option value="SHA-512" selected>SHA-512 (128-byte blocks)</option>
        </select>
    </div>

    <div class="container">
        <label for="info-input">Paste your 'info' string here:</label>
        <textarea id="info-input">Example info string</textarea>
    </div>

    <div class="container" id="prepend-buttons">
        <button data-length="16">Prepend 16 bytes</button>
        <button data-length="32">Prepend 32 bytes</button>
        <button data-length="64">Prepend 64 bytes</button>
    </div>
    
    <div class="legend">
        Legend:
        <div><div class="key-block" style="width:20px; height:20px;"></div>HMAC Key Block</div>
        <div><div class="t-prev" style="width:20px; height:20px;"></div>T(i-1)</div>
        <div><div class="info" style="width:20px; height:20px;"></div>info</div>
        <div><div class="counter" style="width:20px; height:20px;"></div>counter (i)</div>
        <div>
            Padding:
            <div class="legend-viz">
                <div class="eom" title="End of Message (0x80)"></div>
                <div class="unused" title="Unused"></div>
                <div class="length" title="Length"></div>
            </div>
        </div>
    </div>

    <div id="visualization-area"></div>

<script>
    const HASH_PARAMS = {
        'SHA-256': { B: 64, L: 32, LEN_BYTES: 8 },
        'SHA-512': { B: 128, L: 64, LEN_BYTES: 16 }
    };

    const hashSelect = document.getElementById('hash-select');
    const infoInput = document.getElementById('info-input');
    const vizArea = document.getElementById('visualization-area');

    let prependCharIndex = 0;
    const PREPEND_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

    function createSegment(className, byteLength, totalBytes, text) {
        const seg = document.createElement('div');
        seg.className = `segment ${className}`;
        seg.style.width = `${(byteLength / totalBytes) * 100}%`;
        seg.textContent = `${text} (${byteLength}B)`;
        return seg;
    }

    function createPaddingWrapper(byteLength, totalBytes) {
        const wrapper = document.createElement('div');
        wrapper.className = 'padding-wrapper';
        wrapper.style.width = `${(byteLength / totalBytes) * 100}%`;
        return wrapper;
    }

    function renderBlocks(title, hasTPrev, params) {
        const { B, L, LEN_BYTES } = params;
        const infoBytes = new TextEncoder().encode(infoInput.value);
        const infoLen = infoBytes.length;

        const section = document.createElement('div');
        section.className = 'output-section';
        const header = document.createElement('h2');
        header.textContent = title;
        section.appendChild(header);

        let blockIndex = 1;

        const keyBlockLabel = document.createElement('div');
        keyBlockLabel.className = 'block-label';
        keyBlockLabel.textContent = `Block ${blockIndex++} (HMAC Inner Key)`;
        section.appendChild(keyBlockLabel);
        const keyBlockContainer = document.createElement('div');
        keyBlockContainer.className = 'block-container';
        keyBlockContainer.appendChild(createSegment('key-block', B, B, 'K\' âŠ• ipad'));
        section.appendChild(keyBlockContainer);

        const tPrevLen = hasTPrev ? L : 0;
        const counterLen = 1;
        const messageLen = tPrevLen + infoLen + counterLen;
        let bytesProcessed = 0;

        while (bytesProcessed < messageLen) {
            const blockContainer = document.createElement('div');
            blockContainer.className = 'block-container';
            const blockLabel = document.createElement('div');
            blockLabel.className = 'block-label';
            blockLabel.textContent = `Block ${blockIndex++} (Message)`;
            section.appendChild(blockLabel);
            section.appendChild(blockContainer);

            const blockStart = bytesProcessed;
            const blockEnd = bytesProcessed + B;

            if (hasTPrev && blockStart < tPrevLen) {
                const len = Math.min(tPrevLen, blockEnd) - blockStart;
                blockContainer.appendChild(createSegment('t-prev', len, B, 'T(i-1)'));
            }

            const infoStartInMsg = tPrevLen;
            const infoEndInMsg = tPrevLen + infoLen;
            if (blockEnd > infoStartInMsg && blockStart < infoEndInMsg) {
                const start = Math.max(blockStart, infoStartInMsg);
                const end = Math.min(blockEnd, infoEndInMsg);
                const len = end - start;
                blockContainer.appendChild(createSegment('info', len, B, 'info'));
            }

            const counterStartInMsg = tPrevLen + infoLen;
            if (blockEnd > counterStartInMsg && blockStart <= counterStartInMsg) {
                blockContainer.appendChild(createSegment('counter', 1, B, 'i'));
            }
            
            bytesProcessed = blockEnd;
        }
        
        const lastBlockContentSize = messageLen > 0 ? (messageLen - 1) % B + 1 : 0;
        const paddingOverhead = 1 + LEN_BYTES;
        const needsExtraBlock = (lastBlockContentSize + paddingOverhead > B);
        const lastBlock = section.querySelector('.block-container:last-of-type');
        
        if (!needsExtraBlock) {
            const totalPaddingSize = B - lastBlockContentSize;
            const unusedSpace = totalPaddingSize - paddingOverhead;
            const padWrapper = createPaddingWrapper(totalPaddingSize, B);
            
            padWrapper.appendChild(createSegment('eom', 1, totalPaddingSize, 'EOM'));
            if (unusedSpace > 0) {
                padWrapper.appendChild(createSegment('unused', unusedSpace, totalPaddingSize, 'Unused'));
            }
            padWrapper.appendChild(createSegment('length', LEN_BYTES, totalPaddingSize, 'Length'));
            lastBlock.appendChild(padWrapper);
        } else {
            const spaceInFirstPadBlock = B - lastBlockContentSize;
            if (spaceInFirstPadBlock > 0) {
                const firstPadWrapper = createPaddingWrapper(spaceInFirstPadBlock, B);
                const unusedInFirst = spaceInFirstPadBlock - 1;
                firstPadWrapper.appendChild(createSegment('eom', 1, spaceInFirstPadBlock, 'EOM'));
                if (unusedInFirst > 0) {
                    firstPadWrapper.appendChild(createSegment('unused', unusedInFirst, spaceInFirstPadBlock, 'Unused'));
                }
                lastBlock.appendChild(firstPadWrapper);
            }

            const padBlockContainer = document.createElement('div');
            padBlockContainer.className = 'block-container';
            const padBlockLabel = document.createElement('div');
            padBlockLabel.className = 'block-label';
            padBlockLabel.textContent = `Block ${blockIndex++} (Padding)`;
            
            const secondPadWrapper = createPaddingWrapper(B, B);
            const unusedInSecondBlock = B - LEN_BYTES;
            secondPadWrapper.appendChild(createSegment('unused', unusedInSecondBlock, B, 'Unused'));
            secondPadWrapper.appendChild(createSegment('length', LEN_BYTES, B, 'Length'));
            
            padBlockContainer.appendChild(secondPadWrapper);
            section.appendChild(padBlockLabel);
            section.appendChild(padBlockContainer);
        }
        return section;
    }

    function updateVisualization() {
        vizArea.innerHTML = '';
        const params = HASH_PARAMS[hashSelect.value];
        vizArea.appendChild(renderBlocks('Case 1: First Output Block (T(1))', false, params));
        vizArea.appendChild(renderBlocks('Case 2: Subsequent Blocks (T(i > 1))', true, params));
    }

    hashSelect.addEventListener('change', updateVisualization);
    infoInput.addEventListener('input', updateVisualization);

    document.querySelectorAll('#prepend-buttons button').forEach(button => {
        button.addEventListener('click', (event) => {
            const length = parseInt(event.target.dataset.length, 10);
            const char = PREPEND_CHARS[prependCharIndex % PREPEND_CHARS.length];
            infoInput.value = char.repeat(length) + infoInput.value;
            prependCharIndex++;
            infoInput.dispatchEvent(new Event('input'));
        });
    });

    updateVisualization();
</script>

</body>
</html>